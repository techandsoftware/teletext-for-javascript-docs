# Demo: Animation

This uses [`plot()`](../teletext-screen-api#plot-graphiccolnum-graphicrownum) and the browser's [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame) to spin a rotating cube. A graphics attribute is set at the start of every row on each frame to activate mosaic graphics for that row. The cube code was AI-generated.

<ClientOnly>

<div id="screen"></div>

<script setup>
import { runDemoInVitepress } from './runDemoCodeHelper.js';
import { Attributes, Colour, Teletext } from '@techandsoftware/teletext';

runDemoInVitepress(() => {

    const t = Teletext();
    t.addTo('#screen');
    
    const cube = new SpinningCube(t, 78, 75);
    cube.animate();

    return () => t.destroy(); // cleanup after unmount in vitepress
});


// this was generated by ChatGPT

const FRAME_RATE = 20; // fps

class SpinningCube {
  constructor(teletext, width, height) {
    this.teletext = teletext;
    this.width = width;
    this.height = height;
    this.cx = width / 2;
    this.cy = height / 2;
    this.scale = 20;
    this.angle = 0;
    this.lastFrameTime = 0;

    this.vertices = [
      [-1, -1, -1],
      [ 1, -1, -1],
      [ 1,  1, -1],
      [-1,  1, -1],
      [-1, -1,  1],
      [ 1, -1,  1],
      [ 1,  1,  1],
      [-1,  1,  1],
    ];

    this.edges = [
      [0,1],[1,2],[2,3],[3,0], // bottom face
      [4,5],[5,6],[6,7],[7,4], // top face
      [0,4],[1,5],[2,6],[3,7], // vertical edges
    ];
  }

  clearScreen() {
    this.teletext.clearScreen(false);
    for (let r = 0; r < 25; r++) {
      this.teletext.writeByte(0, r, '\x13');
    }
  }

  drawLine(x0, y0, x1, y1) {
    let dx = Math.abs(x1 - x0);
    let dy = Math.abs(y1 - y0);
    let sx = x0 < x1 ? 1 : -1;
    let sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;

    while (true) {
      if (x0 >= 0 && x0 < this.width && y0 >= 0 && y0 < this.height) {
        this.teletext.plot(x0, y0);
      }
      if (x0 === x1 && y0 === y1) break;
      let e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x0 += sx; }
      if (e2 < dx) { err += dx; y0 += sy; }
    }
  }

  project(x, y) {
    return [this.cx + x * this.scale, this.cy + y * this.scale];
  }

  drawCube() {
    // Cache trig
    const angle = this.angle;
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    const cosB = Math.cos(angle * 0.7);
    const sinB = Math.sin(angle * 0.7);

    // Rotate and project vertices
    const projected = this.vertices.map(([x, y, z]) => {
      // rotateX
      const y1 = y * cosA - z * sinA;
      const z1 = y * sinA + z * cosA;
      // rotateY
      const x2 = x * cosB + z1 * sinB;
      const y2 = y1;
      // project and round
      const [px, py] = this.project(x2, y2);
      return [Math.round(px), Math.round(py)];
    });

    // Draw edges
    this.edges.forEach(([i1, i2]) => {
      const [x0, y0] = projected[i1];
      const [x1, y1] = projected[i2];
      this.drawLine(x0, y0, x1, y1);
    });

    this.teletext.updateDisplay();
  }

  animate(timestamp = 0) {
    if (!this.lastFrameTime) this.lastFrameTime = timestamp;
    const elapsed = timestamp - this.lastFrameTime;

    if (elapsed > 1000 / FRAME_RATE) {
      this.clearScreen();
      this.drawCube();
      this.angle += 0.05;
      this.lastFrameTime = timestamp;
    }

    requestAnimationFrame(this.animate.bind(this));
  }
}

</script>
</ClientOnly>
