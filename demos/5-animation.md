# Demo: Animation

This uses [`plot()`](../teletext-screen-api#plot-graphiccolnum-graphicrownum) and the browser's [`requestAnimationFrame()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame) to spin a rotating cube. A graphics attribute is set at the start of every row on each frame to activate mosaic graphics for that row. Mosaic graphics use characters 0x20 to 0x3f and 0x60 to 0x7f in the G1 set. The cube code was AI-generated.

The graphic display options swtich between contiguous and separated mosaics. The third option is text, which removes the graphics attributes to show the corresponding character from the G0 set instead.

<label for="graphicsSelector">Graphics display options</label><br>
<select style="margin-bottom: 1rem;" id="graphicsSelector">
    <option value="contiguous">Graphics - contiguous</option>
    <option value="separated">Graphics - separated</option>
    <option value="text">Text</option>
</select>

<ClientOnly>

<div id="screen"></div>

<script setup>
import { runDemoInVitepress } from './runDemoCodeHelper.js';
import { Attributes, Colour, Teletext } from '@techandsoftware/teletext';

const FRAME_RATE = 20; // fps
let clearScreenArray;


runDemoInVitepress(() => {

  document.querySelector('#graphicsSelector').onchange = setGraphicsAttributes;
  setGraphicsAttributes();

  const t = Teletext();
  t.addTo('#screen');
  t.setDefaultG0Charset('g0_latin__english');
  
  const cube = new SpinningCube(t, 78, 75);
  cube.animate();

  return () => {  // cleanup after unmount in vitepress
    cube.stop();
    t.destroy();
  }
});


function setGraphicsAttributes() {
  const val = document.querySelector('#graphicsSelector').value;
  let graphicAttributes;

  if (val == "contiguous") {
      graphicAttributes = '\x13 '; // yellow mosaics
  }
  else if (val == "separated") {
      graphicAttributes = '\x13\x1a'; //yellow mosaics separated
  }
  else if (val == "text") {
      graphicAttributes = '  '; // default text
  }
  const row = graphicAttributes.padEnd(40, " ");
  clearScreenArray = Array(25).fill(row);
}

// this was generated by ChatGPT
class SpinningCube {
  constructor(teletext, width, height) {
    this.teletext = teletext;
    this.width = width;
    this.height = height;
    this.cx = width / 2;
    this.cy = height / 2;
    this.scale = 20;
    this.angle = 0;
    this.lastFrameTime = 0;
    this.stopped = false;

    this.vertices = [
      [-1, -1, -1],
      [ 1, -1, -1],
      [ 1,  1, -1],
      [-1,  1, -1],
      [-1, -1,  1],
      [ 1, -1,  1],
      [ 1,  1,  1],
      [-1,  1,  1],
    ];

    this.edges = [
      [0,1],[1,2],[2,3],[3,0], // bottom face
      [4,5],[5,6],[6,7],[7,4], // top face
      [0,4],[1,5],[2,6],[3,7], // vertical edges
    ];
  }

  clearScreen() {
    this.teletext.writeBytes(0, 0, clearScreenArray, false);
  }

  drawLine(x0, y0, x1, y1) {
    let dx = Math.abs(x1 - x0);
    let dy = Math.abs(y1 - y0);
    let sx = x0 < x1 ? 1 : -1;
    let sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;

    while (true) {
      if (x0 >= 0 && x0 < this.width && y0 >= 0 && y0 < this.height) {
        this.teletext.plot(x0, y0);
      }
      if (x0 === x1 && y0 === y1) break;
      let e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x0 += sx; }
      if (e2 < dx) { err += dx; y0 += sy; }
    }
  }

  project(x, y) {
    return [this.cx + x * this.scale, this.cy + y * this.scale];
  }

  drawCube() {
    // Cache trig
    const angle = this.angle;
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    const cosB = Math.cos(angle * 0.7);
    const sinB = Math.sin(angle * 0.7);

    // Rotate and project vertices
    const projected = this.vertices.map(([x, y, z]) => {
      // rotateX
      const y1 = y * cosA - z * sinA;
      const z1 = y * sinA + z * cosA;
      // rotateY
      const x2 = x * cosB + z1 * sinB;
      const y2 = y1;
      // project and round
      const [px, py] = this.project(x2, y2);
      return [Math.round(px), Math.round(py)];
    });

    // Draw edges
    this.edges.forEach(([i1, i2]) => {
      const [x0, y0] = projected[i1];
      const [x1, y1] = projected[i2];
      this.drawLine(x0, y0, x1, y1);
    });

    this.teletext.updateDisplay();
  }

  animate(timestamp = 0) {
    if (!this.lastFrameTime) this.lastFrameTime = timestamp;
    const elapsed = timestamp - this.lastFrameTime;

    if (elapsed > 1000 / FRAME_RATE) {
      this.clearScreen();
      this.drawCube();
      this.angle += 0.05;
      this.lastFrameTime = timestamp;
    }

    if (!this.stopped) {
      requestAnimationFrame(this.animate.bind(this));
    }
  }

  stop() {
    this.stopped = true;
  }
}

</script>
</ClientOnly>
