# Demo: Conway's Game of Life

An implementation of [Conway's Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life). This uses the G1 mosaic graphics, with a segment for each cell. The left-most column has an attribute to activate graphics for each row, giving a game grid of 78x75. A 2d array is used for the life simulation, and written to the display per frame using [`plot()`](../teletext-screen-api#plot-graphiccolnum-graphicrownum).

<button id="restartButton">Restart Game</button>

<ClientOnly>

<div id="screen"></div>

<script setup>
import { runDemoInVitepress } from './runDemoCodeHelper.js';
import { Level, Teletext } from '@techandsoftware/teletext';

const FPS = 15;

runDemoInVitepress(() => {

  document.querySelector('#restartButton').onclick = restart;
  const t = Teletext();
  t.setLevel(Level[1.5]);
  t.addTo('#screen');
  setClearScreenAttributes();
  
  const brain = new BriansBrain(t, 40, 25);
  brain.animate();

  function restart() {
    brain.restart();
  }

  return () => {  // cleanup after unmount in vitepress
    brain.stop();
    t.destroy();
  }
});

const colours = ['\x12', '\x13', '\x15', '\x16', '\x17'];

let clearScreenArray;

function setClearScreenAttributes() {
  const attributes = '\x10\x1e\x7f'; // black graphics, activate held mosaic, mosaic 111111 (\x7f in G1)
  clearScreenArray = Array(25).fill(attributes.padEnd(40, '\x7f'));
}

// Generated by ChatGPT
class BriansBrain {
  constructor(teletext, width, height) {
    this.teletext = teletext;
    this.width = width - 3; // allow for 3 left-most cells to be used for attributes
    this.height = height;
    this.grid = this.randomGrid();
    this.lastFrameTime = 0;
    this.stopped = false;
    this.frames = 0;
  }

  randomGrid() {
    return Array.from({ length: this.height }, () =>
      Array.from({ length: this.width }, () => Math.random() > 0.92 ? 1 : 0)
    );
  }

  step() {
    const next = Array.from({ length: this.height }, () =>
      Array(this.width).fill(0)
    );

    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        const state = this.grid[y][x];
        if (state === 1) {
          next[y][x] = 2; // ON → DYING
        } else if (state === 2) {
          next[y][x] = 0; // DYING → OFF
        } else { // OFF
          let onNeighbors = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = (x + dx + this.width) % this.width;
              const ny = (y + dy + this.height) % this.height;
              if (this.grid[ny][nx] === 1) onNeighbors++;
            }
          }
          if (onNeighbors === 2) next[y][x] = 1; // OFF → ON
        }
      }
    }

    this.grid = next;
  }

  clearScreen() {
    this.teletext.writeBytes(0, 0, clearScreenArray, false);
  }

  render() {
    this.clearScreen();
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        const state = this.grid[y][x];
        if (state == 0) this.teletext.writeByte(x + 3, y, '\x10', false); // OFF - black
        else if (state == 1) this.teletext.writeByte(x + 3, y, '\x17', false); // ON - white
        else if (state == 2) this.teletext.writeByte(x + 3, y, '\x11', false); // DYING - red
      }
    }
  }

  animate(timestamp = 0) {
    if (!this.lastFrameTime) this.lastFrameTime = timestamp;
    const elapsed = timestamp - this.lastFrameTime;

    if (elapsed > 1000 / FPS) {
      this.step();
      this.render();
      this.teletext.updateDisplay();
      this.lastFrameTime = timestamp;
      this.frames++;
      // console.log(elapsed);
      // if (this.frames == 3) this.stopped = true;
    }

    if (!this.stopped) {
      requestAnimationFrame(this.animate.bind(this));
    }
  }

  restart() {
    this.grid = this.randomGrid();
  }

  stop() {
    this.stopped = true;
  }
}

</script>
</ClientOnly>
